---
title: "A1 - Preproceso de datos"
author: "Autor: Morten Nyborg"
date: "Octubre 2021"
output:
  html_document:
    highlight: default
    number_sections: yes
    theme: cosmo
    toc: yes
    toc_depth: 2
  word_document: default
  pdf_document:
    highlight: zenburn
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r echo=FALSE, message=FALSE, warning=FALSE}
if(!require(data.table)){
    install.packages('data.table',repos='http://cran.es.r-project.org')
    require(data.table)
}
if(!require(ggplot2)){
    install.packages('ggplot2',repos='http://cran.es.r-project.org')
    require(ggplot2)
}
if(!require(MASS)){
    install.packages('MASS', repos='http://cran.es.r-project.org')
    require(MASS)
}
if(!require(plyr)){
    install.packages('plyr', repos='http://cran.es.r-project.org')
    require(plyr)
}
if(!require(psych)){
    install.packages('psych', repos='http://cran.es.r-project.org')
    require(psych)
}
if(!require(VIM)){
    install.packages('VIM', repos='http://cran.es.r-project.org')
    require(VIM)
}
```



# Carga del archivo.  
  
Cargamos los datos.  
```{r echo=TRUE, message=FALSE, warning=FALSE}
# Loading data.
insureClaim <- read.csv("./train3.csv", header = TRUE, stringsAsFactors = FALSE, sep = ";")

```  


Con el comando dim vemos que hay 54000 filas y 15 columnas.

```{r}
dim(insureClaim)
```


Mostramos la estructura de los datos. Las variables Age, DependentChildren, DependentsOther,DaysWorkedPerWeek y InitialIncurredCalimsCost son eteros. Las demás variables son character. DateTimeOfAccident y DateReported deberían ser de formato Date y UltimateIncurredClaimCost debería ser de formato numérico.


```{r echo=TRUE, message=FALSE, warning=FALSE}

str(insureClaim)
``` 


Resumen estadístico.


```{r echo=TRUE, message=FALSE, warning=FALSE}
summary(insureClaim)

``` 



  
# Duplicación de códigos.  
  
Comprabamos si hay claimnumber dublicados y encontramos 4.  


```{r echo=TRUE, message=FALSE, warning=FALSE}

# Duplicates
insureClaim$ClaimNumber[duplicated(insureClaim$ClaimNumber)]

``` 

Vamos a generar números claimNumber y para ello encontramos el mayor número que existe hasta ahora y añadiremos 1 para cada uno de los claimNumbers duplicados.


```{r echo=TRUE, message=FALSE, warning=FALSE}

# max claimNumber
max(insureClaim$ClaimNumber)
``` 





Separamos el último claimNumber en characters y integers y vamos sumando 1 hasta tener 4 int sucesivos. A estos int les añadimos "wc" delante. Reemplazamos los números duplicados por los nuevos que hemos generado.  
  
  
```{r}

# max claimNumber
valu = max(insureClaim$ClaimNumber)

# Split to string and int
valu1 = as.integer(substr(valu, 3, 9)) + 1

# Sequence of numbers
num.seq = seq(valu1, valu1 + length(insureClaim$ClaimNumber[duplicated(insureClaim$ClaimNumber)]) - 1, 1)

# Paste
new_vals = paste("WC", as.character(num.seq), sep="")

# Overwrite duplicates
insureClaim$ClaimNumber[duplicated(insureClaim$ClaimNumber)] = new_vals

```
 


Verificamos que ya no hay duplicados.  


```{r echo=TRUE, message=FALSE, warning=FALSE}

insureClaim$ClaimNumber[duplicated(insureClaim$ClaimNumber)]

```





# Nombres de las variables.  

Damos nombre a las variables y verificamos que se ha hecho el cambio

```{r echo=TRUE, message=FALSE, warning=FALSE}

colnames(insureClaim)[colnames(insureClaim) 
                      %in% c("HoursWorkedPerWeek","DaysWorkedPerWeek","InitialIncurredCalimsCost","UltimateIncurredClaimCost")] <-
                      c("HoursWeek","DaysWeek","IniCost","UltCost")

```

```{r echo=TRUE, message=FALSE, warning=FALSE}
colnames(insureClaim)
``` 



# Normalización de los datos cualitativos.  


## Marital Status.

Comprobamos los valores únicos de la variable MaritalStatus. Existen 10 valores diferentes, en mayúsculas y minúsculas.

```{r echo=TRUE, message=FALSE, warning=FALSE}

class(insureClaim$MaritalStatus)

``` 

```{r echo=TRUE, message=FALSE, warning=FALSE}

unique(insureClaim$MaritalStatus)

```

Hacemos las sustituciones necesarias: "married" por "M", "" por "U", para el resto ponemos todo en mayúsculas. Una vez hechos los cambios, verificamos que son los esperados.    

```{r echo=TRUE, message=FALSE, warning=FALSE}

# Replace "married" with "M".
insureClaim$MaritalStatus[insureClaim$MaritalStatus == "married"] <- "M"

# Replace "" with "U".
insureClaim$MaritalStatus[insureClaim$MaritalStatus == ""] <- "U"

# Transfer the whole column to upper case.
insureClaim$MaritalStatus <- toupper(insureClaim$MaritalStatus)

```

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Verify the results.
unique(insureClaim$MaritalStatus)

``` 




## Género 

Comprobamos los géneros diferentes en el dataset.  

```{r echo=TRUE, message=FALSE, warning=FALSE}

# Unique values in column
unique(insureClaim$Gender)

```

Sustituimos "Fm" por "U" y transformamos todos los datos a mayúsculas. Comprobamos que no hay duplicados.  


```{r echo=TRUE, message=FALSE, warning=FALSE}

# Replacements and upper case
insureClaim$Gender[insureClaim$Gender=="Fm"] <- "U"
insureClaim$Gender <- toupper(insureClaim$Gender)

```

```{r echo=TRUE, message=FALSE, warning=FALSE}

# Unique values in column
unique(insureClaim$Gender)

```



# Normalización de los datos cuantitativos.  
## IniCost y UltCost.

Las variables que representan coste inicial y coste final tienen formatos integer y character.  

```{r echo=TRUE, message=FALSE, warning=FALSE}

# Data type
class(insureClaim$IniCost)
class(insureClaim$UltCost)

```

```{r echo=TRUE, message=FALSE, warning=FALSE}

head(insureClaim$IniCost)
head(insureClaim$UltCost)
```

UltCost se interpreta como character porque contiene un punto y algunos valores contienen la letra "K". El separador debe ser punto. Comprobamos si hay alguna coma en las columnas de coste inicial y coste final.  

No existen valores que contengan coma en ninguna de las columnas.  

```{r echo=TRUE, message=FALSE, warning=FALSE}

# Check for comma as separator.
unique(insureClaim$IniCost[regexpr("\\,", insureClaim$IniCost)!=-1])

unique(insureClaim$UltCost[regexpr("\\,", insureClaim$UltCost)!=-1])

```

Identificamos los valores que tienen la letra "K" por sus índices. Guardamos los índices.  

Sobre el subset de datos por sus índices eliminamos la letra K y volvemos a comprobar si queda algún valor que contenga cualquier letra.  

```{r echo=TRUE, message=FALSE, warning=FALSE}

# Save indexes
idxs <- which(regexpr("[a-zA-Z]", insureClaim$UltCost)!=-1,)

# Get rows with the indexes
length(insureClaim$UltCost[idxs])


# Remove "k" from rows that have it
insureClaim$UltCost[idxs] <- gsub("[kK]", "", insureClaim$UltCost[idxs]) 

# Check again if there are any other characters left
which(regexpr("[a-zA-Z]", insureClaim$UltCost)!=-1,)
```


Los valores resultantes (identificados por sus índices) los multiplicamos por 1000, redondeamos el resultado y guardamos todo como enteros.  


```{r echo=TRUE, message=FALSE, warning=FALSE}

# Multiply by 1000, round and to numberic value.
insureClaim$UltCost[idxs] <- round(as.numeric(insureClaim$UltCost[idxs]) * 1000)

# Rest of the column to numberic and round.
insureClaim$UltCost[-idxs] <- round(as.numeric(insureClaim$UltCost[-idxs]))

# To integer.
insureClaim$UltCost <- as.integer(insureClaim$UltCost)


```


Comprobamos ahora los primeras y las últimas líneas de coste inicial y de coste final y el tipo de variable que guardan las columnas. Ahora UltCost es entero.  

```{r echo=TRUE, message=FALSE, warning=FALSE}
# head and tail of ultCost.
head(insureClaim$UltCost)
tail(insureClaim$UltCost)

```

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Verify the class of the ultCost
class(insureClaim$UltCost)

```




## Edad.  


Vemos las edades únicas, comprobamos que la variable es de tipo entero.  

```{r echo=TRUE, message=FALSE, warning=FALSE}

# Unique ages
sort(unique(insureClaim$Age))

```
Outliers 999




```{r echo=TRUE, message=FALSE, warning=FALSE}

class(insureClaim$Age)

```



## Weekly Wages, HoursWeek, DaysWeek.  

DaysWeek es una variable de tipo entero y contiene días de la semana de 1 a 7, como esperabamos.  

```{r echo=TRUE, message=FALSE, warning=FALSE}

class(insureClaim$DaysWeek)

```

```{r echo=TRUE, message=FALSE, warning=FALSE}

sort(unique(insureClaim$DaysWeek))

```

La mayoría de gente en el dataset trabaja 5 días a la semana  



```{r echo=TRUE, message=FALSE, warning=FALSE}

barplot(table(insureClaim$DaysWeek), main = "Days of Week", col = "red")

```






HoursWeek es una variable de tipo character, aunque tendría más sentido que sea otro tipo, como integer o double.  

Las personas trabajan entre 0 y 93 horas, aunque aparecen algunas que trabajan 380 horas a la semana. Parece que se ha omitido el punto decimal en estos casos.  


```{r echo=TRUE, message=FALSE, warning=FALSE}

class(insureClaim$HoursWeek)

```

```{r echo=TRUE, message=FALSE, warning=FALSE}

sort(unique(insureClaim$HoursWeek))

```

Reemplaamos las comas en la variable HoursWeek y la guardamos como numérica.  

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Replace comma with period.

insureClaim$HoursWeek <- gsub(",", ".", insureClaim$HoursWeek)

```

```{r echo=TRUE, message=FALSE, warning=FALSE}

insureClaim$HoursWeek <- as.numeric(insureClaim$HoursWeek)

```

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Verify class of hoursWeek
class(insureClaim$HoursWeek)

```



La mayoría de observaciones trabaja 37.5 horas semanales.  
```{r echo=TRUE, message=FALSE, warning=FALSE}

barplot(table(insureClaim$HoursWeek), main = "Hours per Week", col = "cyan")

```

En el histograma podemos ver que existen valores de horas semanales de hasta 600, pero son pocos.  


En el boxplot también podemos ver los valores extremos.  

```{r echo=TRUE, message=FALSE, warning=FALSE}

boxplot(insureClaim$HoursWeek, main = "Hours per week")


```




Weeklywages

La variable de sueldo semanal es de tipo character

```{r echo=TRUE, message=FALSE, warning=FALSE}
class(insureClaim$WeeklyWages)


```

```{r echo=TRUE, message=FALSE, warning=FALSE}

head(sort(unique(insureClaim$WeeklyWages)))
tail(sort(unique(insureClaim$WeeklyWages)))

```

Reemplazamos la coma por punto, guardamos la variable como variable numérica y comprobamos que el cámbio se ha hecho.  

```{r echo=TRUE, message=FALSE, warning=FALSE}

# Replace comma with period.
insureClaim$WeeklyWages <- gsub(",", ".", insureClaim$WeeklyWages)

```



```{r echo=TRUE, message=FALSE, warning=FALSE}

# Save as numeric
insureClaim$WeeklyWages <- as.numeric(insureClaim$WeeklyWages)

```

```{r echo=TRUE, message=FALSE, warning=FALSE}

# Check class
class(insureClaim$WeeklyWages)

```

```{r echo=TRUE, message=FALSE, warning=FALSE}
head(insureClaim$WeeklyWages)

```


La mayoría de personas tienen sueldos semanales de 20
```{r echo=TRUE, message=FALSE, warning=FALSE}

barplot(table(insureClaim$WeeklyWages), main = "Weekly Wages", col = "red", )

```

La mayoría de observaciones tienen sueldos semanales por debajo de 500  

```{r echo=TRUE, message=FALSE, warning=FALSE}

truehist(insureClaim$WeeklyWages, nbins = 50)

```

```{r}
ggplot(mapping = aes(x=insureClaim$WeeklyWages)) + geom_density()
```





# Valores atípicos. 


AGE

Esta variable tiene 12 valores atípicos (999). 

En el boxplot los valores atípicos son los que están fuera del cuartil 3 + 1.5 Rango intercuartil o por debajo de el cuartil 1 - 1.5 Rango intercuartil. Estos límites se representan con líneas horizontales.  



```{r echo=TRUE, message=FALSE, warning=FALSE}

boxplot(insureClaim$Age, main = "Distribution of Age")

```
  
El valor de la mediana es 32, de la media 34, pero la media se ve más influenciada por el valor atípico.  

```{r echo=TRUE, message=FALSE, warning=FALSE}

summary(insureClaim$Age)

```

```{r echo=TRUE, message=FALSE, warning=FALSE}

count(insureClaim$Age == 999)

```

Reemplazamos los valores centinela por NA y vemos que el cambio se ha hecho. El valor máximo es 81.  

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Set 999 to variable.
val.centinela <- 999
# Substitute the value with NA.
insureClaim$Age[insureClaim$Age == val.centinela] <-NA
# Verify the result
summary(insureClaim$Age)


```




WeeklyWages.

Los sueldos semanales tienen outliers, podemos verlo en el boxplot.  

```{r echo=TRUE, message=FALSE, warning=FALSE}

boxplot(insureClaim$WeeklyWages, main = "Box plot Weekly wages", col = "red")

```

El sueldo semanal más alto corresponde a 7497.  

```{r echo=TRUE, message=FALSE, warning=FALSE}
summary(insureClaim$WeeklyWages)


```


Hay muchos sueldos mayores que 1000 a la semana. El sueldo máximo es de 7497, que sería de 390 000 con 52 semanas en el año. En Australia el sueldo medio para cirujanos, por ejemplo, es de 395 000. Así podemos considerar que el sueldo de 7497 a la semana es una cifra razonable.  

Hay 1131 obsevaciones con sueldos semanales por encima de 1000.  

```{r echo=TRUE, message=FALSE, warning=FALSE}
dim(insureClaim[insureClaim$WeeklyWages > 1000,])


```


days a week


En los días por semana, tenemos personas que trabajan desde 1 día hasta 7, con la mediana de 5 días y media de 4.9.  
```{r echo=TRUE, message=FALSE, warning=FALSE}

summary(insureClaim$DaysWeek)

```

```{r echo=TRUE, message=FALSE, warning=FALSE}

sort(unique(insureClaim$DaysWeek))

```


HOURSWEEK

En horas por semana tenemos un máximo de 640. 

24 * 7 = 168 es el número de horas en la semana. Trabajo por 15 horas al día daría 105 horas semanales  

Sería imposible trabajar mas de 168 horas a la semana y difícil trabajar más de 105.  

```{r echo=TRUE, message=FALSE, warning=FALSE}

summary(insureClaim$HoursWeek)

```
El boxplot muestra que hay outliers.  

```{r echo=TRUE, message=FALSE, warning=FALSE}

boxplot(insureClaim$HoursWeek, main = "Box plot Hour per week", col = "blue")

```
  
Hay 37 instancias en las que las horas semanales son mayores que las horas que tiene una semana.  

```{r echo=TRUE, message=FALSE, warning=FALSE}

count(insureClaim$HoursWeek >= 168)

```

Asignamos valores NA a todas las observaciones en las que hay más o igual de 168 horas semanales.  


```{r echo=TRUE, message=FALSE, warning=FALSE}
# Set limit for working hours a week.
val.limit <- 168
# Substitute those higher with NA.
insureClaim$HoursWeek[insureClaim$HoursWeek >= val.limit] <- NA
# Verify results.
summary(insureClaim$HoursWeek)
```





# Imputación de valores. 


Detectamos por su índice las observaciones que tienen valores NA de la variable Age. Sobreescribimos estos valores con la media de todos los valores de la variable Age.  

```{r echo=TRUE, message=FALSE, warning=FALSE}

insureClaim1 <- insureClaim

# saving index of na.
idx_age_NA <- which(is.na(insureClaim1$Age))
# Before imputation
insureClaim1[idx_age_NA,]
# Age calculated by the mean of all ages, non NA
insureClaim1$Age[is.na(insureClaim1$Age)] <- as.integer(mean(insureClaim1$Age[!is.na(insureClaim1$Age)]))
# After imputation.
insureClaim1[idx_age_NA,]

```

Guardamos las variables cuantitativas con las que vamos a trabajar.

Guardamos los índices en los que HoursWeek es NA. Imputamos los valores con kNN, lo hacemos por separado para el subconjunto de hombres, mujeres, y sexo sesconocido. Antes de hacer la imputación mostramos los datos NA y lo hacemos despés de imputar. Veremos que después de imputar para el sexo masculino, desaparecen los NA en este sexo. Lo mismo ocurre cuando imputamos para sexo "F" y "U".     


Hemos dividido los datos por sexo. Para cada sexo y para cada registro de dicho sexo, kNN busca los registros del mismo sexo más parecidos y usa estos datos para imputar valores NA.  

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Numeric variables. 
cuantitativas <- c("Age", "DependentChildren", "DependentsOther", "WeeklyWages", "HoursWeek", "DaysWeek", "IniCost", "UltCost")

colSums(is.na(insureClaim1))

# Saving index of na for male.
inx_num_NA <- which(is.na(insureClaim1$HoursWeek))

# Before imputation.
insureClaim1[inx_num_NA, c("Age", "Gender", "HoursWeek")]

insureClaim1[insureClaim1$Gender=="M", cuantitativas] <- kNN(data=insureClaim1[insureClaim1$Gender=="M", cuantitativas], metric="Gower")
# After imputation.
insureClaim1[inx_num_NA, c("Age", "Gender", "HoursWeek")]
```


```{r echo=TRUE, message=FALSE, warning=FALSE}

inx_num_NA <- which(is.na(insureClaim1$HoursWeek))

# Before imputation.
insureClaim1[inx_num_NA, c("Age", "Gender", "HoursWeek")]

insureClaim1[insureClaim1$Gender=="F", cuantitativas] <- kNN(data=insureClaim1[insureClaim1$Gender=="F", cuantitativas], metric="Gower")

# After imputation.
insureClaim1[inx_num_NA, c("Age", "Gender", "HoursWeek")]
```


```{r echo=TRUE, message=FALSE, warning=FALSE}

inx_num_NA <- which(is.na(insureClaim1$HoursWeek))

# Before imputation.
insureClaim1[inx_num_NA, c("Age", "Gender", "HoursWeek")]

insureClaim1[insureClaim1$Gender=="U", cuantitativas] <- kNN(data=insureClaim1[insureClaim1$Gender=="U", cuantitativas], metric="Gower")



#After imputation
insureClaim1[inx_num_NA, c("Age", "Gender", "HoursWeek")]

```





# Preparación de los datos.  
## Tiempo de abertura del expendiente.  

El tipo de dato en en las variables DateReported y DateTimeOfAccident es character, tendría que ser formato Date

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Check the class of "dateReported".
class(insureClaim1$DateReported)


```

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Check the class of "DateTimeOfAccident.
class(insureClaim1$DateTimeOfAccident)

```



Comprobamos el formato.  

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Check the format of the date columns.
tail(insureClaim1$DateTimeOfAccident)
head(insureClaim1$DateReported)
```
Guardamos las dos variables como fecha y comprobamos que el cambio hha sido efectivo  


```{r echo=TRUE, message=FALSE, warning=FALSE}
# Convert DateTimeOfAccident to Date format.
insureClaim1$DateTimeOfAccident <- as.Date(insureClaim1$DateTimeOfAccident, "%Y-%m-%d")

```

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Convert DateReported to Date format.
insureClaim1$DateReported <- as.Date(insureClaim1$DateReported, "%Y-%m-%d")

```

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Verify the conversion to Date format.
class(insureClaim1$DateReported)
class(insureClaim1$DateTimeOfAccident)

```

Calculamos la diferencia entre en días entre el día de apertura del expediente y el día del accidente.  

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Create the column Time and calculate the difference in days.
insureClaim1$Time <- as.integer(difftime(insureClaim1$DateReported, insureClaim1$DateTimeOfAccident, units = "days"))

```

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Check the new column created.
head(insureClaim1$Time)

```




## Diferencia entre IniCost y UltCost.  


Calculamos la variable DifCost.  

```{r echo=TRUE, message=FALSE, warning=FALSE}

insureClaim1$DifCost <- insureClaim1$UltCost - insureClaim1$IniCost

```

```{r echo=TRUE, message=FALSE, warning=FALSE}

head(insureClaim1$DifCost)

```

En el gráfico de barras podemos ver que la mayoría de veces la diferencia entre la estimación y el coste es cercana a cero. Hay más estimaciones con DifCost mayor que cero, esto quiere decir que el coste final ha sido mayor del coste inicial estimado.  

```{r echo=TRUE, message=FALSE, warning=FALSE}

barplot(table(insureClaim1$DifCost), main = "Diference in cost between ultcost and inicost", col = "red", )

```




# Estudio descriptivo.  
## Funciones de media robustas.  

Creamos la función para calcular la media recortada. En primer lugar calculamos el número de valores que tenemos que recortar por los bordes (largo de los datos por porcentaje que pasamos a la función).

Ordenamos el rango de datos, y creamos un subconjunto de los datos ordenados, eliminando un número de observaciones por cada lado. De este subconjunto calculamos la media.  

```{r echo=TRUE, message=FALSE, warning=FALSE}

media.recortada <- function(x, perc=0.05){
  # To remove on each side
  no.removed = length(x) * perc

  # Sort data
  x.sorted = sort(x)
  
  # Trim data
  new.range = x.sorted[(no.removed+1):(length(x)-no.removed)]
  
  return(sum(new.range)/length(new.range))
  
}

```


Comprobamos que la función devuelve el mismo resultado que la función de media recortada en R
```{r echo=TRUE, message=FALSE, warning=FALSE}


media.recortada(insureClaim1$Age)
```

```{r echo=TRUE, message=FALSE, warning=FALSE}

mean(insureClaim1$Age, trim=0.05)


```

La función para calcular la media Winsor primero calcula el número de observaciones que tienen que ser reemplazadas por otras (por cada lado), luego ordena el rango de valores. Reemplaza el primer n porciento de las observaciones (ordenadas) por el primer valor después de ese conjunto. Reemplaza las n % últimas observaciones por el valor que precede ese conjunto.  

```{r echo=TRUE, message=FALSE, warning=FALSE}

media.winsor <- function(x, perc=0.05){
  # Obs to replace
  no.removed = length(x) * perc
  
  # Sort
  x.sorted = sort(x)
  
  # Assign value to first perc of observations
  x.sorted[1:no.removed] <- x.sorted[(no.removed+1)]
  
  # Assign values to last perc of observations
  x.sorted[(length(x)-no.removed+1):length(x)] <- x.sorted[(length(x)-no.removed)]
  
  return(sum(x.sorted)/length(x.sorted))
}

```


Comprobamos que nuestra función devuelve el mismo valor que la función de R
```{r echo=TRUE, message=FALSE, warning=FALSE}

media.winsor(insureClaim1$Age)

```

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Verification of function with r built function.
winsor.mean(insureClaim1$Age, trim=0.05)

```



## Estudio descriptivo de las variables cuantitativas.  

Guardamos las variables cuantitativas

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Quantative data
quant.var <- c("Age","WeeklyWages","DaysWeek","HoursWeek","IniCost","UltCost")
table.var.df <- insureClaim1[quant.var]
head(table.var.df)
```

Creamos una tabla que contiene medidas de tendencia central y dispersión robustas y no robustas.  

Las medidas de tendencia central robustas son la mediana, la media recortada y la media winsor. Estas medidas son menos sensibles a los valores extremos. 

Las medidas de dispersión robustas son el rango intercuartílico y la desviación absoluta de la mediana. 


```{r echo=TRUE, message=FALSE, warning=FALSE}
# Create table.
descr.table <- data.table(
  "var" = quant.var,
  "mean" = sapply(table.var.df, mean),
  "median" = sapply(table.var.df, median),
  "trimmed mean" = sapply(table.var.df, media.recortada),
  "wins. mean" = sapply(table.var.df, media.winsor),
  "stnd dev" = sapply(table.var.df, sd),
  "IQR" = sapply(table.var.df, IQR),
  "med. abs. dev." = sapply(table.var.df, mad)
)
descr.table
```

Creamos una función para visualizar los datos.

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Visualization function.

vizu <- function(data, colm, title){
  oldpar = par(mfrow = c(2,2), mar=c(2,2,2,2))
  truehist(data[[colm]], main = title, col = "orange")
  abline(v = mean(data[[colm]]), col="red", lwd=3, lty=2);
  abline(v = median(data[[colm]]), lwd=3, lty=2, col="blue");
  qqnorm(data[[colm]], main = title);qqline(data[[colm]], col = 2 )
  
  boxplot(data[[colm]], main = title)
}


```


Después de haber limpiado los datos, ya no hay valores atípicos. La variable Age tiene una mediana menor que la media, como también podemos ver en la tabla. No sigue una distribución normal. Según el boxplot, entre el cuartil 27 y 75 están las personas de 20 a 40 años.  

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Plot age.
vizu(insureClaim1, "Age", "Age")


```

WeeklyWages. Hay mucha diferencia entre sueldos semanales en las observaciones. La mediana es de 392 y la media de 416.No sigue una distribución normal.   

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Plot weeklyWages.
vizu(insureClaim1, "WeeklyWages", "WeeklyWages")


```


La mayoría de personas trabajan 5 días a la semana, y esta es la mediana. La media es menor, es más habitual encontrar personas que trabajen menos de 5 días que más.  


```{r echo=TRUE, message=FALSE, warning=FALSE}
# Plot DaysWeek
vizu(insureClaim1, "DaysWeek", "DaysWeek")


```

La mayoría de la personas del dataset trabajan menos de 40 horas (media 37.4, mediana 38). 

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Plot HoursWeek
vizu(insureClaim1, "HoursWeek", "HoursWeek")


```



En el coste inicial aunque no se ve en el histograma, la media y la mediana son bastante diferentes. Hay mucha dispersión, el rango de valores que toma la variable es amplio, aunque la mayoría de valores son bajos. 
```{r echo=TRUE, message=FALSE, warning=FALSE}
# Plot IniCost
vizu(insureClaim1, "IniCost", "IniCost")


```

En coste final también hay mucha dispersión. Los costes finales suelen ser bajos.  
```{r echo=TRUE, message=FALSE, warning=FALSE}
# Plot UltCost
vizu(insureClaim1, "UltCost", "UltCost")


```


# Archivo final.  

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Write to file.
write.csv(insureClaim1,"./train_clean.csv", row.names = FALSE)


```




# Evaluación de la actividad.  

